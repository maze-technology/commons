name: Publish

on:
  push:
    branches:
      - main

env:
  JAVA_HOME: "" # INFO: Force JAVA_HOME to be empty, so gradle will use the sdkman java version
  NODE_VERSION: "22"
  PYTHON_VERSION: "3.13"
  SMITHYTRANSLATE_VERSION: "0.5.7"
  BUF_VERSION: "1.55.1"
  GITHUB_TOKEN: ${{ github.token }}
  GITHUB_USERNAME: x-access-token

jobs:
  prepare_tag:
    name: Setup Tag
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.bump_version.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v5

      - name: Bump version and push tag
        id: bump_version
        uses: anothrNick/github-tag-action@1.75.0
        env:
          DEFAULT_BUMP: patch
          DRY_RUN: true

  package:
    name: Package and Publish
    runs-on: ubuntu-latest
    needs: [prepare_tag]
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - name: Cache SDKMAN
        uses: actions/cache@v4
        with:
          path: ~/.sdkman
          key: sdkman-${{ runner.os }}-${{ hashFiles('.sdkmanrc') }}

      - name: Install SDKMAN
        uses: sdkman/sdkman-action@b1f9b696c79148b66d3d3a06f7ea801820318d0f

      # INFO: Tell Gradle which JDK to use *regardless* of what happens to JAVA_HOME
      - name: Point Gradle at the SDKMAN JDK
        run: echo "JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> $GITHUB_ENV

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5

      - name: Setup Coursier
        uses: coursier/setup-action@v1

      - name: Setup SmithyTranslate
        run: cs install --channel https://disneystreaming.github.io/coursier.json smithytranslate:${{ env.SMITHYTRANSLATE_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Buf
        run: npm install -g @bufbuild/buf@${{ env.BUF_VERSION }}

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Build with Makefile
        run: make build

      - name: Extract Maven coordinates
        id: maven_coords
        run: |
          # Get coordinates from Gradle task
          COORDS=$(./gradlew -q printCoordinates)

          GROUP_ID=$(echo "$COORDS" | grep '^group=' | cut -d= -f2)
          ARTIFACT_ID=$(echo "$COORDS" | grep '^artifactId=' | cut -d= -f2)

          if [ -z "$GROUP_ID" ] || [ -z "$ARTIFACT_ID" ]; then
            echo "Could not extract Maven coordinates from Gradle"
            echo "Output was: $COORDS"
            exit 1
          fi

          # Convert group dots to slashes for Maven path (e.g., "tech.maze" -> "tech/maze")
          GROUP_PATH=$(echo "$GROUP_ID" | tr '.' '/')

          echo "group=$GROUP_ID" >> $GITHUB_OUTPUT
          echo "artifact=$ARTIFACT_ID" >> $GITHUB_OUTPUT
          echo "group_path=$GROUP_PATH" >> $GITHUB_OUTPUT
          echo "Extracted: group=$GROUP_ID, artifact=$ARTIFACT_ID, group_path=$GROUP_PATH"

      - name: Get latest published version
        id: get_latest_version
        run: |
          # Get the latest release tag
          LATEST_TAG=$(gh api repos/${{ github.repository }}/releases/latest --jq '.tag_name' 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No published version found, skipping baseline comparison"
            echo "has_baseline=false" >> $GITHUB_OUTPUT
          else
            echo "latest_version=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "has_baseline=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download latest published JAR
        if: steps.get_latest_version.outputs.has_baseline == 'true'
        run: |
          VERSION="${{ steps.get_latest_version.outputs.latest_version }}"
          GROUP_PATH="${{ steps.maven_coords.outputs.group_path }}"
          ARTIFACT="${{ steps.maven_coords.outputs.artifact }}"
          mkdir -p baseline-jar
          # Download from GitHub Packages Maven repository
          JAR_URL="https://maven.pkg.github.com/${{ github.repository }}/${GROUP_PATH}/${ARTIFACT}/${VERSION}/${ARTIFACT}-${VERSION}.jar"
          echo "Downloading JAR from: $JAR_URL"
          curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -o baseline-jar/${ARTIFACT}-${VERSION}.jar \
            "$JAR_URL" || echo "JAR not found, will skip baseline"
        continue-on-error: true

      # INFO: This scan creates a baseline for diffing. It's non-blocking so missing/failed
      # base results don't fail the job; the comparison step will handle gating based on new vulns.
      - name: Scan baseline JAR with Trivy
        id: scan_baseline
        if: steps.get_latest_version.outputs.has_baseline == 'true'
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/baseline-jar"
          format: "json"
          output: "baseline-trivy-results.json"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      # NOTE: Human-readable table output for reviewers. Exit code is forced to 0 because
      # the next step (comparison) is responsible for failing the build if new HIGH/CRITICAL
      # vulnerabilities are introduced by this release.
      - name: Scan current build with Trivy
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/build/libs"
          format: "table"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      # NOTE: Machine-readable JSON used by the subsequent comparison step to diff against the
      # base scan and detect any newly introduced HIGH/CRITICAL vulnerabilities.
      - name: Scan current build with Trivy (JSON for comparison)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: "fs"
          scan-ref: "${{ github.workspace }}/build/libs"
          format: "json"
          output: "current-trivy-results.json"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      # NOTE: Diffs HIGH/CRITICAL vulns between base and new builds. Fails the job only if the new
      # release introduces new HIGH/CRITICAL items; otherwise it passes but informs about existing ones.
      # Only runs if baseline scan succeeded and baseline file is valid.
      - name: Compare vulnerabilities and fail on new ones
        if: always() && steps.get_latest_version.outputs.has_baseline == 'true' && steps.scan_baseline.outcome == 'success'
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os

          def extract_vulns(json_file):
              """Extract unique vulnerability IDs from trivy JSON output"""
              try:
                  with open(json_file, 'r') as f:
                      data = json.load(f)
                  vulns = set()
                  for result in data.get('Results', []):
                      for vuln in result.get('Vulnerabilities', []):
                          vuln_id = vuln.get('VulnerabilityID', '')
                          if vuln_id:
                              vulns.add(vuln_id)
                  return vulns
              except (FileNotFoundError, json.JSONDecodeError, KeyError):
                  return set()

          baseline_file = 'baseline-trivy-results.json'
          current_file = 'current-trivy-results.json'

          # Validate baseline file exists and is not empty
          if not os.path.exists(baseline_file) or os.path.getsize(baseline_file) == 0:
              print("⚠️  Baseline scan results are missing or empty. Skipping comparison.")
              print("   This may happen if the baseline JAR download failed or the scan failed.")
              print("   Current build vulnerabilities will be shown but comparison is skipped.")
              sys.exit(0)

          baseline_vulns = extract_vulns(baseline_file)
          current_vulns = extract_vulns(current_file)

          # Validate baseline has valid data
          if not baseline_vulns and os.path.getsize(baseline_file) > 0:
              # File exists but has no vulnerabilities - this is valid
              print("ℹ️  Baseline scan found no vulnerabilities (empty baseline).")
          elif not baseline_vulns:
              print("⚠️  Baseline scan results are invalid. Skipping comparison.")
              sys.exit(0)

          new_vulns = current_vulns - baseline_vulns
          fixed_vulns = baseline_vulns - current_vulns

          print(f"Baseline vulnerabilities: {len(baseline_vulns)}")
          print(f"Current vulnerabilities: {len(current_vulns)}")
          print(f"New vulnerabilities: {len(new_vulns)}")
          print(f"Fixed vulnerabilities: {len(fixed_vulns)}")

          if new_vulns:
              print("\n❌ NEW VULNERABILITIES DETECTED:")
              for vuln in sorted(new_vulns):
                  print(f"  - {vuln}")
              sys.exit(1)
          elif fixed_vulns:
              print("\n✅ Some vulnerabilities were fixed:")
              for vuln in sorted(fixed_vulns):
                  print(f"  - {vuln}")
          else:
              print("\n✅ No new vulnerabilities detected")
          EOF

      - name: Publish library ${{ needs.prepare_tag.outputs.VERSION }}
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: ./gradlew -Pversion=${{ needs.prepare_tag.outputs.VERSION }} publish

  release:
    name: Release ${{ needs.prepare_tag.outputs.VERSION }}
    runs-on: ubuntu-latest
    needs: [prepare_tag, package]
    permissions:
      contents: write
    steps:
      - name: Create Tag
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "refs/tags/${{ needs.prepare_tag.outputs.VERSION }}",
              sha: context.sha
            })

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Build Changelog
        id: build_changelog
        uses: mikepenz/release-changelog-builder-action@v6

      - name: Create Release
        uses: actions/github-script@v8
        env:
          RELEASE_BODY: ${{ steps.build_changelog.outputs.CHANGELOG }}
        with:
          github-token: ${{ github.token }}
          script: |
            const changelog = process.env.RELEASE_BODY;
            github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: "${{ needs.prepare_tag.outputs.VERSION }}",
              name: "${{ needs.prepare_tag.outputs.VERSION }}",
              body: changelog,
              generate_release_notes: true
            })
